import { Injectable } from '@nestjs/common';
import { FilesService } from '../files/files.service';
import PDFDocument = require('pdfkit');

export interface ProposalPdfData {
  title: string;
  content: string;
  authorName: string;
  authorEmail: string;
  createdAt: Date;
  signatures?: {
    signerName: string;
    signerEmail: string;
    signedAt: Date;
    signatureUrl?: string;
  }[];
}

@Injectable()
export class PdfService {
  constructor(private filesService: FilesService) {}

  async generateProposalPdf(data: ProposalPdfData): Promise<Buffer> {
    const doc = new PDFDocument({ margin: 50 });
    const chunks: Buffer[] = [];
    
    return await new Promise<Buffer>((resolve, reject) => {
      doc.on('data', (chunk) => chunks.push(chunk as Buffer));
      doc.on('end', () => resolve(Buffer.concat(chunks)));
      doc.on('error', reject);

      // Header
      doc.fontSize(20).text('PROPOSAL', { align: 'center' });
      doc.moveDown();

      // Title
      doc.fontSize(16).text(data.title, { align: 'center' });
      doc.moveDown();

      // Author info
      doc.fontSize(12)
         .text(`Prepared by: ${data.authorName}`)
         .text(`Email: ${data.authorEmail}`)
         .text(`Date: ${data.createdAt.toLocaleDateString()}`);
      doc.moveDown();

      // Content
      const content = data.content
        .replace(/<\s*br\s*\/?\s*>/gi, '\n')
        .replace(/<\s*p\s*>/gi, '\n')
        .replace(/<[^>]+>/g, '')
        .trim();

      doc.fontSize(12).text(content);
      doc.moveDown(2);

      // Signatures section
      if (data.signatures && data.signatures.length > 0) {
        doc.fontSize(14).text('SIGNATURES', { underline: true });
        doc.moveDown();

        data.signatures.forEach((signature, index) => {
          doc.fontSize(12)
             .text(`Signer ${index + 1}: ${signature.signerName}`)
             .text(`Email: ${signature.signerEmail}`)
             .text(`Signed on: ${signature.signedAt.toLocaleDateString()}`);
          
          if (signature.signatureUrl) {
            doc.text('Signature: [Digital signature attached]');
          }
          doc.moveDown();
        });
      }

      // Footer
      doc.fontSize(10)
         .text('Generated by Proposal Management System', 50, doc.page.height - 50, {
           align: 'center'
         });

      doc.end();
    });
  }

  async generateFromHtml(html: string): Promise<Buffer> {
    // Very simple HTML to text rendering for PDFKit; for rich HTML use puppeteer.
    const doc = new PDFDocument({ margin: 50 });
    const chunks: Buffer[] = [];
    return await new Promise<Buffer>((resolve, reject) => {
      doc.on('data', (chunk) => chunks.push(chunk as Buffer));
      doc.on('end', () => resolve(Buffer.concat(chunks)));
      doc.on('error', reject);

      const text = html
        .replace(/<\s*br\s*\/?\s*>/gi, '\n')
        .replace(/<\s*p\s*>/gi, '\n')
        .replace(/<[^>]+>/g, '')
        .trim();

      doc.fontSize(16).text(text || '');
      doc.end();
    });
  }

  async generatePreview(proposalData: ProposalPdfData): Promise<Buffer> {
    // Add watermark for preview
    const doc = new PDFDocument({ margin: 50 });
    const chunks: Buffer[] = [];
    
    return await new Promise<Buffer>((resolve, reject) => {
      doc.on('data', (chunk) => chunks.push(chunk as Buffer));
      doc.on('end', () => resolve(Buffer.concat(chunks)));
      doc.on('error', reject);

      // Watermark
      doc.fontSize(50)
         .fillColor('lightgray')
         .text('PREVIEW', 0, 200, { 
           align: 'center',
           opacity: 0.3 
         });

      // Reset color for content
      doc.fillColor('black');

      // Generate normal content
      this.addProposalContent(doc, proposalData);
      doc.end();
    });
  }

  private addProposalContent(doc: any, data: ProposalPdfData) {
    // Header
    doc.fontSize(20).text('PROPOSAL', { align: 'center' });
    doc.moveDown();

    // Title
    doc.fontSize(16).text(data.title, { align: 'center' });
    doc.moveDown();

    // Author info
    doc.fontSize(12)
       .text(`Prepared by: ${data.authorName}`)
       .text(`Email: ${data.authorEmail}`)
       .text(`Date: ${data.createdAt.toLocaleDateString()}`);
    doc.moveDown();

    // Content
    const content = data.content
      .replace(/<\s*br\s*\/?\s*>/gi, '\n')
      .replace(/<\s*p\s*>/gi, '\n')
      .replace(/<[^>]+>/g, '')
      .trim();

    doc.fontSize(12).text(content);
  }
}
